import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// ../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// ../../node_modules/extendible/index.js
var require_extendible = __commonJS({
  "../../node_modules/extendible/index.js"(exports, module) {
    var has = Object.prototype.hasOwnProperty;
    var slice = Array.prototype.slice;
    function copypaste(obj) {
      var args = slice.call(arguments, 1), i = 0, prop;
      for (; i < args.length; i++) {
        if (!args[i]) continue;
        for (prop in args[i]) {
          if (!has.call(args[i], prop)) continue;
          obj[prop] = args[i][prop];
        }
      }
      return obj;
    }
    function mixin(obj) {
      if ("function" !== typeof Object.getOwnPropertyNames || "function" !== typeof Object.defineProperty || "function" !== typeof Object.getOwnPropertyDescriptor) {
        return copypaste.apply(null, arguments);
      }
      slice.call(arguments, 1).forEach(function forEach(o) {
        Object.getOwnPropertyNames(o).forEach(function eachAttr(attr) {
          Object.defineProperty(obj, attr, Object.getOwnPropertyDescriptor(o, attr));
        });
      });
      return obj;
    }
    function mode(parent) {
      try {
        var e = parent.caller || parent.arguments || parent.callee;
        return function child() {
          return parent.apply(this, arguments);
        };
      } catch (e2) {
      }
      return function child() {
        "use strict";
        return parent.apply(this, arguments);
      };
    }
    module.exports = function extend(protoProps, staticProps) {
      var parent = this, child;
      if (protoProps && has.call(protoProps, "constructor")) {
        child = protoProps.constructor;
      } else {
        child = mode(parent);
      }
      function Surrogate() {
        this.constructor = child;
      }
      Surrogate.prototype = parent.prototype;
      child.prototype = new Surrogate();
      if (protoProps) mixin(child.prototype, protoProps);
      copypaste(child, parent, staticProps);
      child.__super__ = parent.prototype;
      return child;
    };
  }
});

// ../../node_modules/requests/requested.js
var require_requested = __commonJS({
  "../../node_modules/requests/requested.js"(exports, module) {
    "use strict";
    var EventEmitter = require_eventemitter3();
    function Requested(url, options) {
      EventEmitter.call(this);
      this.merge(this, Requested.defaults, options || {});
      this.id = ++Requested.requested;
      this.readable = true;
      this.writable = false;
      if (this.initialize) this.initialize(url);
      if (!this.manual && this.open) this.open(url);
    }
    Requested.extend = require_extendible();
    Requested.prototype = new EventEmitter();
    Requested.prototype.constructor = Requested;
    Requested.prototype.typeof = function type(what) {
      return Object.prototype.toString.call(what).slice(8, -1).toLowerCase();
    };
    Requested.prototype.merge = function merge(target) {
      var i = 1, arg, key;
      for (; i < arguments.length; i++) {
        arg = arguments[i];
        for (key in arg) {
          if (!Object.prototype.hasOwnProperty.call(arg, key)) continue;
          if ("object" === this.typeof(arg[key])) {
            target[key] = this.merge("object" === this.typeof(target[key]) ? target[key] : {}, arg[key]);
          } else {
            target[key] = arg[key];
          }
        }
      }
      return target;
    };
    Requested.defaults = {
      streaming: false,
      manual: false,
      method: "GET",
      mode: "cors",
      headers: {
        //
        // We're forcing text/plain mode by default to ensure that regular
        // requests can benefit from CORS requests without an OPTIONS request. It's
        // shared between server and client implementations to ensure that requests
        // are handled in exactly the same way.
        //
        "Content-Type": "text/plain"
      }
    };
    Requested.requested = 0;
    module.exports = Requested;
  }
});

// ../../node_modules/xhr-response/index.js
var require_xhr_response = __commonJS({
  "../../node_modules/xhr-response/index.js"(exports, module) {
    "use strict";
    module.exports = function get(xhr) {
      if (xhr.response) return xhr.response;
      var type = xhr.responseType || "";
      if (~type.indexOf("moz-chunked") && xhr.readyState === 4) return;
      if ("blob" !== type && "string" === typeof xhr.responseText) {
        return xhr.responseText || xhr.responseXML;
      }
    };
  }
});

// ../../node_modules/xhr-status/index.js
var require_xhr_status = __commonJS({
  "../../node_modules/xhr-status/index.js"(exports, module) {
    "use strict";
    module.exports = function status(xhr) {
      var local = /^file:/.test(xhr.responseURL), code = xhr.status, text = "";
      if (1233 === code) return {
        error: false,
        text: "OK",
        code: 204
      };
      if (0 === code) return local ? {
        error: false,
        text: "OK",
        code: 200
      } : {
        error: true,
        text: "An unknown error occured",
        code: 0
      };
      try {
        text = xhr.statusText;
      } catch (e) {
      }
      return {
        error: code >= 400,
        text,
        code
      };
    };
  }
});

// ../../node_modules/one-time/index.js
var require_one_time = __commonJS({
  "../../node_modules/one-time/index.js"(exports, module) {
    "use strict";
    module.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called) return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = fn.displayName || fn.name || onetime.displayName || onetime.name;
      return onetime;
    };
  }
});

// ../../node_modules/failure/index.js
var require_failure = __commonJS({
  "../../node_modules/failure/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    function toJSON() {
      var obj = { message: this.message, stack: this.stack }, key;
      for (key in this) {
        if (has.call(this, key) && "function" !== typeof this[key]) {
          obj[key] = this[key];
        }
      }
      return obj;
    }
    module.exports = function failure(err, props) {
      if (!err) err = "Unspecified error";
      if ("string" === typeof err) err = new Error(err);
      if (props) for (var prop in props) {
        if (!(prop in err) && has.call(props, prop)) {
          err[prop] = props[prop];
        }
      }
      if ("function" !== typeof err.toJSON) err.toJSON = toJSON;
      return err;
    };
  }
});

// ../../node_modules/loads/index.js
var require_loads = __commonJS({
  "../../node_modules/loads/index.js"(exports, module) {
    "use strict";
    var response = require_xhr_response();
    var statuscode = require_xhr_status();
    var one = require_one_time();
    var fail = require_failure();
    function nope() {
    }
    function loads(xhr, ee) {
      var onreadystatechange, onprogress, ontimeout, onabort, onerror, onload, timer;
      onerror = xhr.onerror = one(function onerror2(evt) {
        var status = statuscode(xhr), err = fail(new Error("Network request failed"), status);
        ee.emit("error", err);
        ee.emit("end", err, status);
      });
      onabort = xhr.onabort = function onabort2(evt) {
        onerror(evt);
      };
      onreadystatechange = xhr.onreadystatechange = function change(evt) {
        var target = evt.target;
        if (4 === target.readyState) return onload(evt);
      };
      ontimeout = xhr.ontimeout = one(function timeout(evt) {
        ee.emit("timeout", evt);
        if (xhr.abort) xhr.abort();
        onerror(evt);
      });
      if (xhr.timeout) timer = setTimeout(ontimeout, +xhr.timeout);
      onprogress = xhr.onprogress = function progress(evt) {
        var status = statuscode(xhr), data;
        ee.emit("progress", evt, status);
        if (xhr.readyState >= 3 && status.code === 200 && (data = response(xhr))) {
          ee.emit("stream", data, status);
        }
      };
      onload = xhr.onload = one(function load(evt) {
        var status = statuscode(xhr), data = response(xhr);
        if (status.code < 100 || status.code > 599) return onerror(evt);
        if (data && status.code !== 204) {
          ee.emit("stream", data, status);
        }
        ee.emit("end", void 0, status);
      });
      ee.once("end", function cleanup() {
        xhr.onreadystatechange = onreadystatechange = xhr.onprogress = onprogress = xhr.ontimeout = ontimeout = xhr.onerror = onerror = xhr.onabort = onabort = xhr.onload = onload = nope;
        if (timer) clearTimeout(timer);
      });
      return xhr;
    }
    module.exports = loads;
  }
});

// ../../node_modules/xhr-send/index.js
var require_xhr_send = __commonJS({
  "../../node_modules/xhr-send/index.js"(exports, module) {
    "use strict";
    module.exports = function send(xhr, data, fn) {
      try {
        xhr.send(data);
      } catch (e) {
        return fn(e), false;
      }
      return fn(), true;
    };
  }
});

// ../../node_modules/hang/index.js
var require_hang = __commonJS({
  "../../node_modules/hang/index.js"(exports, module) {
    "use strict";
    module.exports = function hang(fn) {
      var start = +/* @__PURE__ */ new Date();
      function bro() {
        var self = this;
        if (+/* @__PURE__ */ new Date() > start) {
          return fn.apply(self, arguments);
        }
        for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {
          args[i] = arguments[i];
        }
        (global.setImmediate || global.setTimeout)(function delay() {
          fn.apply(self, args);
          self = args = null;
        }, 0);
      }
      bro.displayName = fn.displayName || fn.name || bro.displayName || bro.name;
      return bro;
    };
  }
});

// ../../node_modules/axo/index.js
var require_axo = __commonJS({
  "../../node_modules/axo/index.js"(exports, module) {
    module.exports = function AXO(x, i) {
      var target = typeof global !== "undefined" ? global : window;
      for (i = 0; i < x.length; i++) {
        x[i] = String.fromCharCode(x[i].charCodeAt(0) + i);
      }
      return target[x.join("")];
    }("Abrfr`RHZa[Xh".split(""));
  }
});

// ../../node_modules/node-http-xhr/lib/browser.js
var require_browser = __commonJS({
  "../../node_modules/node-http-xhr/lib/browser.js"(exports, module) {
    "use strict";
    module.exports = window.XMLHttpRequest;
  }
});

// ../../node_modules/requests/index.js
var require_requests = __commonJS({
  "../../node_modules/requests/index.js"(exports, module) {
    var Requested = require_requested();
    var listeners = require_loads();
    var send = require_xhr_send();
    var hang = require_hang();
    var AXO = require_axo();
    var XMLHttpRequest = require_browser();
    var Requests = module.exports = Requested.extend({
      constructor: function bobthebuilder(url, options) {
        if (!(this instanceof Requests)) return new Requests(url, options);
        Requested.apply(this, arguments);
      },
      /**
       * The offset of data that we've already previously read
       *
       * @type {Number}
       * @private
       */
      offset: 0,
      /**
       * The requests instance has been fully initialized.
       *
       * @param {String} url The URL we need to connect to.
       * @api private
       */
      initialize: function initialize(url) {
        this.socket = Requests[Requests.method](this);
        this.socket.open(this.method.toUpperCase(), url, true);
        Requests.active[this.id] = this;
      },
      /**
       * Initialize and start requesting the supplied resource.
       *
       * @param {Object} options Passed in defaults.
       * @api private
       */
      open: function open() {
        var what, slice = true, requests = this, socket = requests.socket;
        requests.on("stream", function stream(data) {
          if (!slice) {
            return requests.emit("data", data);
          }
          var chunk = data.slice(requests.offset);
          requests.offset = data.length;
          requests.emit("data", chunk);
        });
        requests.on("end", function cleanup() {
          delete Requests.active[requests.id];
        });
        if (this.timeout) {
          socket.timeout = +this.timeout;
        }
        if ("cors" === this.mode.toLowerCase() && "withCredentials" in socket) {
          socket.withCredentials = true;
        }
        for (what in this.headers) {
          if (this.headers[what] !== void 0 && this.socket.setRequestHeader) {
            this.socket.setRequestHeader(what, this.headers[what] + "");
          }
        }
        if (requests.streaming) {
          if (!this.body || "string" === typeof this.body) {
            if ("multipart" in socket) {
              socket.multipart = true;
              slice = false;
            } else if (Requests.type.mozchunkedtext) {
              socket.responseType = "moz-chunked-text";
              slice = false;
            }
          } else {
            if (Requests.type.mozchunkedarraybuffer) {
              socket.responseType = "moz-chunked-arraybuffer";
            } else if (Requests.type.msstream) {
              socket.responseType = "ms-stream";
            }
          }
        }
        listeners(socket, requests, requests.streaming);
        requests.emit("before", socket);
        send(socket, this.body, hang(function send2(err) {
          if (err) {
            requests.emit("error", err);
            requests.emit("end", err);
          }
          requests.emit("send");
        }));
      },
      /**
       * Completely destroy the running XHR and release of the internal references.
       *
       * @returns {Boolean} Successful destruction
       * @api public
       */
      destroy: function destroy() {
        if (!this.socket) return false;
        this.emit("destroy");
        this.socket.abort();
        this.removeAllListeners();
        this.headers = {};
        this.socket = null;
        this.body = null;
        delete Requests.active[this.id];
        return true;
      }
    });
    Requests.XHR = function create() {
      try {
        return new XMLHttpRequest();
      } catch (e) {
      }
    };
    Requests.AXO = function create() {
      var ids = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "Microsoft.XMLHTTP"], id;
      while (ids.length) {
        id = ids.shift();
        try {
          return new AXO(id);
        } catch (e) {
        }
      }
    };
    Requests.active = {};
    Requests.method = !!Requests.XHR() ? "XHR" : !!Requests.AXO() ? "AXO" : "";
    Requests.supported = !!Requests.method;
    Requests.type = "XHR" === Requests.method ? function detect() {
      var types = "arraybuffer,blob,document,json,text,moz-blob,moz-chunked-text,moz-chunked-arraybuffer,ms-stream".split(","), supported = {}, type, xhr, prop;
      while (types.length) {
        type = types.pop();
        prop = type.replace(/-/g, "");
        xhr = Requests.XHR();
        try {
          xhr.open("get", "/", true);
        } catch (e) {
          try {
            xhr.open("get", "http://localhost/", true);
          } catch (err) {
            supported[prop] = false;
            continue;
          }
        }
        try {
          xhr.responseType = type;
          supported[prop] = "response" in xhr && xhr.responseType === type;
        } catch (e) {
          supported[prop] = false;
        }
        xhr = null;
      }
      return supported;
    }() : {};
    Requests.streaming = "XHR" === Requests.method && ("multipart" in XMLHttpRequest.prototype || Requests.type.mozchunkedarraybuffer || Requests.type.mozchunkedtext || Requests.type.msstream || Requests.type.mozblob);
    if (global.attachEvent) global.attachEvent("onunload", function reap() {
      for (var id in Requests.active) {
        Requests.active[id].destroy();
      }
    });
    module.exports = Requests;
  }
});
export default require_requests();
//# sourceMappingURL=requests.js.map
